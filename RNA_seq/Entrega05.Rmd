---
title: "Reporte_05"
author: "Jessica Garcia, Manuel Rivera, Axel Rodriguez"
date: "2023-03-03"
output:
  html_document:
    toc: true # table of content true
    toc_float: yes
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite
    highlight: tango  # specifies the syntax highlighting style
  pdf_document: 
    toc: true
    toc_depth: 3
    number_sections: true
    pandoc_args: --listings # Para que no se salga el codigo del margen
    includes:
      in_header: preamble.tex
---

# Objetivo: 

Realizar el análisis de datos de RNA-Seq (pipeline completa) obtenidos de células madre de trofoblasto humano tratadas con un inhibidor de JNK (SP600125) y con control DMSO.

--------------------------------------------------------------------------------

# Descripcion de los datos

- Tipo de bibliotecas: Paired-end

- Método de selección: ARN Total, cDNA

- Número de transcriptomas: 6 transcriptomas 

- Número de réplicas biológicas: 3

- Secuenciador: Illumina NovaSeq 6000

- Distribución de las muestras: 

  Control: tratamiento con DMSO (hTSC, DMSO) - SRR18745765 (repbio1), SRR18745766 (repbio1), SRR18745770 (repbio2), SRR18745771 (repbio2), SRR18745772 (repbio2), SRR18745767 (repbio3), SRR18745768 (repbio3), SRR18745769 (repbio3) 

  Tratamiento con SP600125 (hTSC, SP600125) - SRR18745764 (repbio1), SRR18745763 (repbio2) y SRR18745762 (repbio3)

--------------------------------------------------------------------------------

# Abstract

Células hTSC CT27 (células madre de trofoblasto humano) fueron tratadas con SP60015 y con DMSO para evaluar la contribución de los elementos transponibles en la expresión génica como promotores o potencializadores en células de trofoblasto humano. Utilizando los datos epigenéticos del proyecto realizamos un pipeline haciendo uso de varias herramientas y paqueterías como Kallisto quant (pseudoalineamiento), fastqc (análisis de calidad de las lecturas crudas), Trimmomatic (recortar y curar datos), tximport (importar y resumir datos a nivel de transcripción), tidyverse (manipulación, visualización y análisis de datos), DESeq2 (identificar genes que se expresan diferencialmente entre dos o más condiciones experimentales), etc. en donde obtuvimos como resultados que efectivamente los transposones han contribuido de forma importante a la regulación génica del trofoblasto humano.

--------------------------------------------------------------------------------

# Rutas de trabajo generadas en el proyecto

0. Carpeta de trabajo del equipo 

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens 
```

1. Contiene los nombres de los SRA

```{bash}
cat /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/human_fastq.txt
```

2. Contiene las instrucciones de descarga de los datos (SRA) y el cambio a Fastq de los mismos.

```{bash}
cat /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/SRAData_dow.sh
```

3. Contiene el JOB de descarga de los SRA

```{bash}
cat /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/SRA_run.sge
```

4. Contiene los datos crudos y sus fastqc.gz que se enviaron a la carpeta FastQC_rawData para su análisis.

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/data
```

5. Contiene el análisis de calidad de los datos crudos

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_rawData
```

6. Contiene el JOB para recortar y curar datos de Illumina, como eliminar adaptadores de los datos crudos

```{bash}
cat /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/Trimmed_run.sge
```

7. Contiene los adaptadores para paired-end

```{bash}
cat /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/TruSeq3-PE.fa
```

8. Contiene los datos (SRA) sin adaptadores (limpios) y sus fastqc.gz que se enviaron a la carpeta FastQC_trimmed para su análisis

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/data_trimmed
```

9. Contiene el análisis de calidad de los datos limpios, sin adaptadores.

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_trimmed
```

9.1. Contiene el análisis MultiQC de datos sin adaptadores.

```{bash}
cat /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_trimmed/multiqc_report.html
```

10. Contiene el transcriptoma de referencia humano

```{bash}
/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/gencode.v43.transcripts.fa.gz
```

11. Contiene el JOB para hacer uso de Kallisto quant 

```{bash}
cat /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/Kallisto_down_data.sge
```

12. Contiene el JOB para descagar el transcriptoma de referencia humano.

```{bash}
cat /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/Transcript_down.sge
```

13. Contiene el pseudoalineamiento generado con el uso de la herramienta Kallisto

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/kallisto_quant_test
```

## Códigos previos antes de iniciar el análisis

Antes de comenzar todo el proyecto, dentro del cluster guardamos una sesión en screen con la finalidad de poder tener un registro de los comando utilizados durante la práctica 

```{bash}
# Trabajando en el nodo principal generamos un screen
screen -S SRAdata
# Ingresar a un nodo de computo 
qlogin 
```

- screen -S nombre : Guardar tu sesión actual 
- screen -ls : Ver el ID de tus sesiones 
- screen -ls : Ver el ID de tus sesiones 
- Ctrl + a + d : Salir del screen
- Ctrl + a + esc : scroll

```{bash}
# Ingresar a la carpeta de trabajo 
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens 
# Crear una carpeta donde colocaremos los SRA correspondientes a nuestro proyecto que descargaremos de NCBI con ayuda de un JOB 
mkdir data
# Generar un JOB el cual tiene las instrucciones para descargar los SRA del proyecto
nano SRA_run.sge
# Archivo txt que contiene todos los SRA a descargar
nano human_fastq.txt
```

El contenido del nano `human_fastq.txt` es el siguiente

```{bash}
cat human_fastq.txt # Abrir archivo txt 
```

SRR18745762
SRR18745763
SRR18745764	
SRR18745765	
SRR18745766
SRR18745767	
SRR18745768	
SRR18745769	
SRR18745770
SRR18745771
SRR18745772

Por otra parte, el contenido del nano `SRA_run.sge` es el siguiente

```{bash}
cat SRA_run.sge # Abrir archivo JOB con instrucciones de descarga
```

```{bash}
#!/bin/bash
#
# Use Current working directory
#$ -cwd
#
# Join stdout and stderr
#$ -j n
#
# Run job through bash shell
#$ -S /bin/bash
#
# You can edit the script since this line
#
# Your job name
#$ -N Project_Homo
#
# Send an email after the job has finished
#$ -m Manuel
#$ -M rivera20c3@gmail.com
#
#
# If modules are needed, source modules environment (Do not delete the next line):
. /etc/profile.d/modules.sh
#
# Add any modules you might require:
module load sra/3.0.0 # módulo para descagar SRA 
#
# Write your commands in the next line
./SRAData_dow.sh

```

Finalmente para enviar el JOB de descarga y tener las muestras a trabajar usamos el siguiente comando

```{bash}
# Salir de qlogin, moverse a nodo principal para subir JOB
qsub SRA_Hs_run.sge
```


--------------------------------------------------------------------------------

# Resultados y discusión 


## Calidad de secuencias (FastQC y multiQC) de datos crudos.

Primeramente, para analizar los datos crudos creamos dos carpetas. La primera, `data` en donde vamos a almacenar los datos crudos y la segunda, `FastQC_rawData` en donde vamos a tener el análisis de calidad de los mismos. 

```{bash}
# Colocarse en la carpeta de trabajo
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens

# Crear carpetas
mkdir data
mkdir FastQC_rawData
```

Posteriormente, vamos a iniciar el análisis de calidad de las lecturas crudas o sin procesar (raw data)

```{bash}

# cargar module FastQC
qlogin
module load fastqc/0.11.3

# Crear fastqc por lectura
fastqc ./data/*.fastq.gz -o ./FastQC_rawData

```

`fastqc ./data/*.fastq.gz -o ./FastQC_rawData` indica que realice un fastqc a todos los archivos contenidos en la carpeta data que terminen con .fastq.gz y que los outputs los ponga en la carpeta FastQC_rawData.

Ahora bien, se utiliza la herrmaienta MultiQC, la cual crea un único informe con gráficos interactivos para múltiples análisis bioinformáticos en muchas muestras. Se corre el siguiente código.

```{bash}
# Cargar modulo
module load multiqc/1.5
# Generar reporte multiqc
multiqc ./FastQC_rawData -o ./FastQC_rawData
```

Para poder visualizar el informe multiqc,  se descarga el archivo a nuestro ordenador con el siguiente comando:

```{bash}
rsync -rptuvl jgarcia@dna.lavis.unam.mx:/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_rawData/multiqc_report.html .
```

Podemos observar en el histogramas de calidad de secuencias que la mayoría de muestras tienen una calidad aceptable, sin embargo, existen dos SRA con una calidad menor al resto `SRR18745771_1` y `SRR18745768_1` que fue de $24.53$ y $24.78$ respectivamente. Esto puede deberse a muchas razones, entre ellas, el tratamiento experimental llevado en el laboratorio en específico de estas muestras. 


Por otro lado, en la gráfica de contenido de adaptadores observamos que la mayoría de las muestra tienen niveles altos de contaminación de adaptadores. Algunos otros SRA tienen un contenido mucho menor, pero no llegan a un valor considerable para trabajar con estos datos crudos. 


## Limpieza de adaptadores

Para la limpieza de adaptadores primeramente creamos una carpeta llamada `data_trimmed` en donde vamos a almacenar las secuencias limpias que, mediante un job llamado `Trimmed_run.sge` vamos a generar un análisis de datos y posteriormente reedirigirlo a una carpeta llamada `FastQC_trimmed`.

```{bash}
mkdir data_trimmed 
mkdir FastQC_trimmed
nano Trimmed_run.sge
```

El JOB `Trimmed_run.sge` contiene lo siguiente:

```{bash}
cat Trimmed_run.sge
```

```{bash}

#!/bin/bash
#
# Use Current working directory
#$ -cwd
#
# Join stdout and stderr
#$ -j n
#
# Run job through bash shell
#$ -S /bin/bash
#
# You can edit the script since this line
#
# Your job name
#$ -N Trimmed_HommoSappiens
#
# Send an email after the job has finished
#$ -m e
#$ -M axelrdz5205@gmail.com
#
#
# If modules are needed, source modules environment (Do not delete the next line):
. /etc/profile.d/modules.sh
#
# Add any modules you might require:
module load fastqc/0.11.3
module load multiqc/1.5
module load trimmomatic/0.33
# 
# PARTE 1.- FastQC y multiQC
fastqc ./data/*.fastq.gz -o ./FastQC_rawData
multiqc ./FastQC_rawData -o ./FastQC_rawData

# PARTE 2.- Limpieza de adaptadores
# paired-end
cd data
for i in *_1.fastq.gz;
do echo
trimmomatic PE -threads 8 -phred33 $i "${i%_1.fastq.gz}_2.fastq.gz" \
../data_trimmed/"${i%_1.fastq.gz}_1_trimmed.fastq.gz" ../data_trimmed/"${i%_1.fastq.gz}_1_unpaired.fastq.gz" \
../data_trimmed/"${i%_1.fastq.gz}_2_trimmed.fastq.gz" ../data_trimmed/"${i%_1.fastq.gz}_2_unpaired.fastq.gz" \
ILLUMINACLIP:../TruSeq3-PE.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:5:20 MINLEN:60
done

# PARTE 3.- FastQC y multiQC
cd ../
fastqc ./data_trimmed/*.fastq.gz -o ./FastQC_trimmed
# Reporte en MultiQC
multiqc ./FastQC_trimmed -o ./FastQC_trimmed

```

**Trimmomatic** es la herramienta de línea de comandos rápida que utilizamos para recortar y curar datos de Illumina (FASTQ), así como para eliminar adaptadores.


## Calidad de secuencias (FastQC y multiQC) con datos limpios. 

Para analizar la calidad de secuencias descargamos el reporte multiqc a nuestro ordenador.

```{bash}
rsync -rptuvl jgarcia@dna.lavis.unam.mx:/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_trimmed/multiqc_report.html .
```

Para los datos limpios, podemos observar en el histograma de calidad de secuencias un aumento de la calidad. En donde el valor más bajo reportado fue de $29.66$ en una única muestra y el valor más alto fue de $36.73$. 

Ahora bien, en la gráfica de contenido de adaptadores observamos que 7 de las 11 muestras tiene una contaminación de adaptadores bastante baja, 2 de los SRA tienen un contenido por arriba del valor del promedio con valores de: $5.69$ y $6.61$ y otras 2 muy muy por encima del promedio con valores de $21.16$ y $21.66$ de contenido de adaptadores.

## Programa de predicción de cuentas

Continuando con los pasos del pipeline, haremos uso de Kallisto quant el cual es una herramienta de pseudoalineamiento para datos de transcriptoma la cual se basa en la probabilidad de asignación correcta de las lecturas a un transcrito. 

Para ello, creamos una nueva carpeta llamada `kallisto_quant_test` y un JOB llamado `Kallisto_down_data.sge` que contiene las intrucciones para realizar el pseudoalineamiento con ayuda de un transcrito de referencia que obtuvimos con las siguientes líneas de código.

```{bash}
# Carpeta de archivos kallisto
mkdir kallisto_quant_test

# Para descargar transcriptoma de referencia realizamos lo siguiente:

# Generar transcriptoma de referencia mediante el JOB 'Transcript_down.sge', con las instrucciones:
wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.transcripts.fa.gz 

# Creación del JOB para realizar el pseudoalineamiento
nano Kallisto_down_data.sge
```

Información que contiene el JOB `Kallisto_down_data.sge`

```{bash}
cat Kallisto_down_data.sge
```

```{bash}
#!/bin/bash
#
# Use Current working directory
#$ -cwd
#
# Join stdout and stderr
#$ -j n
#
# Run job through bash shell
#$ -S /bin/bash
#
# You can edit the script since this line
#
# Your job name
#$ -N Kallisto_downloaded
#
# Send an email after the job has finished
#$ -m e
#$ -M rivera20c3@gmail.com
#
#
# If modules are needed, source modules environment (Do not delete the next line):
. /etc/profile.d/modules.sh
#
# Add any modules you might require:
module load kallisto/0.45.0
#
# Write your commands in the next line

# Generar index de kallisto
kallisto index ./gencode.v43.transcripts.fa.gz -i ./kallisto_quant2/HS_ref.kidx 

# - i nombre del archivo de salida, i.e., indice
#- Input =  gencode.v43.transcripts.fa.gz, transcriptoma de referencia

 # Paired-end  
for file in ./data_trimmed/*_1_trimmed.fastq.gz                                                 # Read1
do
  clean=$(echo $file | sed 's/_trimmed//;s/\.fastq\.gz//;s/_1//' | sed 's/_trimmed//')         # Nombre de la carpeta de salida, mismo nombre de SRA
  file_2=$(echo ${clean}_2_trimmed.fastq.gz| sed 's/FP/RP/')                                            # Read2
  kallisto quant --index ./kallisto_quant2/HS_ref.kidx --output-dir ./kallisto_quant2/${clean} --threads 12 ${file} ${file_2}
done

```

Ahora bien, para asegurarnos que el pseudoalineamiento se realizó correctamente deberíamos tener los archivos tipo .h5, .tsv y json de cada muestra así que realizamos las siguientes líneas de código para verificar que efectivamente se encuentran esos archivos.

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/kallisto_quant_test
cd SRR18745762 #entrar a cada una de las muestras
ls
```

Observamos que en cada muestra hubo un buen alineamiento, así que procedemos a recuperar estos resultados descargando los datos a nuestro computador con la siguiente línea de comando

```{bash}
# Descagar resultados de kallisto
rsync -rptuvl jgarcia@dna.liigh.unam.mx:/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/kallisto_quant_test/SRR* .
```

Nota: Los archivos de errores del JOB de Kallisto se observan con el siguiente comando

```{bash}
cat Kallisto_down_data.e276381 #ejemplo
```

El siguiente paso que sigue el pipeline que estamos realizando es el análisis de expresión diferencial.

## Análisis de expresión diferencial funcional 

El objetivo del análisis diferencial de expresión es realizar análisis estadísticos para tratar de descubrir cambios en los niveles de expresión de características definidas (genes, transcripciones, exones) entre grupos experimentales con muestras replicadas.

### Instalaciones 

La mayoría de las herramientas populares para el análisis de expresión diferencial están disponibles como paquetes de R / Bioconductor. Bioconductor es un proyecto R y repositorio que proporciona un conjunto de paquetes y métodos para el análisis de datos *omicos*.

Para este proyecto, serán necesarias las siguientes paqueterías:

```{r Librerias, results='hide', message=FALSE}
library(tximport)
library(tidyverse)
library(DESeq2)
library(ggplot2)
library(ggrepel)
library(rhdf5)
```

- `tximport` proporciona una manera de importar y resumir datos a nivel de transcripción generados a partir de herramientas de cuantificación (como `salmon`, `kallisto` y `STAR`) en un formato común que se puede utilizar para el análisis posterior.
- El paquete `tidyverse` es una colección de paquetes en R diseñados para trabajar juntos para hacer más fácil y eficiente la manipulación, visualización y análisis de datos. Su función principal es proporcionar un conjunto coherente e intuitivo de herramientas para la limpieza, transformación y visualización de datos.
- La función principal del paquete `DESeq2` es identificar genes que se expresan diferencialmente entre dos o más condiciones experimentales, basándose en datos de recuento de experimentos de secuenciación de alto rendimiento. DESeq2 is based on the hypothesis that most genes are not differentially expressed. 
- El paquete `ggplot2` proporciona una amplia gama de funciones para crear varios tipos de gráficos, que permite a los usuarios describir y crear *plots* complejos utilizando un conjunto simple y coherente de sintaxis y principios.
- El paquete `ggrepel` en R es un paquete para crear etiquetas de texto que se ajustan automáticamente para evitar solaparse con otras etiquetas o puntos de datos en un gráfico. Su función principal es proporcionar una solución flexible y fácil de usar para etiquetar puntos, líneas u otros elementos gráficos en *plots* complejos creados con `ggplot2` u otros paquetes.

#### Importacion de datos de kallisto en R (*Import transcript-level estimates*)

```{r Intalacion GenomicFeatures, eval=FALSE, include=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("GenomicFeatures")
```

Primero, we create a named vector pointing to the quantification files (los abundance.tsv). We will create a vector of filenames first by reading in a table that contains the SRR, and then combining this with "." and "abundance.tsv".

```{r Metadatos}
# > H. sapiens
# generar tabla de metadatos
Hs_metadata.tsv <- data.frame("SRA" =c("SRR18745765","SRR18745766",  # Control R1
                                       "SRR18745770", "SRR18745771", "SRR18745772",  # Control R2
                                       "SRR18745767", "SRR18745768", "SRR18745769",  # Control R3
                                       "SRR18745764", "SRR18745763", "SRR18745762"),  # JNK_inh
                              "sample" = c("control_1_R1","control_2_R1",
                                           "control_1_R2", "control_2_R2",  "control_3_R2", 
                                           "control_1_R3", "control_2_R3",  "control_3_R3",
                                           "JNK_inh_R1", "JNK_inh_R2", "JNK_inh_R3") , 
                              "dex" = c(rep("control",8), 
                                        rep("JNK_inh",3)), 
                              "species" = "Homo_sapiens")
```

```{r Samples and Files}
# Anotacion articulo
Hs_samples <- Hs_metadata.tsv
Hs_samples
Hs_files   <- file.path("./SRA_experiments", Hs_samples$SRA,"abundance.h5") # Crear ruta a cada archivo abundance de cada SRA
names(Hs_files) <- Hs_samples$SRA # Nombrar las rutas con el nombre de su correspondiente SRA
all(file.exists(Hs_files))
```

- `file.path` te permite crear una ruta a un archivo específico en un directorio de trabajo. En este caso, una ruta para cada archivo `abundance.tsv`

Las transcripciones deben asociarse con identificadores genéticos (*gene IDs*) para el resumen a nivel genético (*gene-level summarization*). Si esa información está presente en los archivos, podemos omitir este paso. Para Salmon, Sailfish, y kallisto los archivos sólo proporcionan el ID de la transcripción. 

Primero hacemos un *data-frame* llamado `tx2gene` con dos columnas: 
  1) ID de la transcripción y 
  2) ID del gen. 
Los nombres de las columnas no importan, pero este orden de columnas debe ser utilizado. El ID de la transcripción debe ser el mismo utilizado en los archivos
`abundance.tsv`. 

```{r creacion archivo csv, eval=FALSE, echo=T}
library(GenomicFeatures)
txdb <- makeTxDbFromGFF(file="gencode.v43.annotation.gtf")
saveDb(x=txdb, file = "gencode.v43.annotation.TxDb")
k <- keys(txdb, keytype = "TXNAME")
tx2gene <- select(txdb, k, "GENEID", "TXNAME")
write.table(tx2gene, "tx2gene.gencode.v43.csv", sep = "\t", row.names = FALSE)
```

Luego leemos en una tabla `tx2gene` (pre-construida), la cual vincula las transcripciones a los genes para este conjunto de datos:

```{r tabla tx2gene Hs}
Hs_tx2gene   <- read.csv("tx2gene.gencode.v43.csv", sep=",",header=TRUE) 
head(Hs_tx2gene)
```

- `read.csv` lee un archivo en formato tabla y crea un *data frame* a partir de el, con casos correspondientes a líneas y variables a campos del archivo.

El paquete `tximport` tiene una sola función para importar estimaciones a nivel de transcripción, es decir los datos de cuantificación necesarios para DESeq2.
- El argumento `type` se utiliza para especificar qué software se utilizó para la estimación, en este caso fue `kallisto`.   
- Se devuelve una lista simple con matrices, `"abundance"`,  `"counts"` y     `"length"` , donde la información del nivel de transcripción se resume al nivel genético.   

Típicamente, la abundancia es proporcionada por las herramientas de cuantificación como TPM (transcripciones-por-millón), mientras que los recuentos son recuentos estimados (posiblemente fraccionales), y la matriz de "longitud" contiene las longitudes efectivas del gen.   
La matriz `"length"` se puede utilizar para generar una matriz de desplazamiento para el análisis diferencial a nivel genético de matrices de conteo (*offset matrix for downstream gene-level differential analysis*), como se muestra abajo.

```{r tximport kallisto}
Hs_txi_kallisto <- tximport(Hs_files, type = "kallisto", tx2gene=Hs_tx2gene, ignoreAfterBar=TRUE)
names(Hs_txi_kallisto)
head(Hs_txi_kallisto$counts)
```

Noté que añadimos un argumento adicional en este fragmento de código, `ignoreAfterBar=TRUE`. Esto se debe a que las transcripciones del código genético tienen nombres como “ENST00000456328. 2|ENSG00000223972. 5|. . . ”, aunque nuestra tabla tx2gene solo incluye el primer identificador “ENST”. Por lo tanto, queremos dividir los nombres de las filas de la matriz de cuantificación entrante en la primera barra “|”, y solo usar esto como identificador.

El usuario debe asegurarse de que los nombres de fila de la tabla `Hs_samples` se alineen con los nombres de columna de `Hs_txi_kallisto$counts`, si hay nombres de fila.

```{r Nombre transcriptomas}
# nombre de los transcriptomas
rownames(Hs_samples) <- Hs_samples$sample # Nombre de cada fila como nombre de la muestra
colnames(Hs_txi_kallisto$counts) <-rownames(Hs_samples) # Nombre de cada columna como nombre de cada muestra
head(rownames(Hs_samples))
head(colnames(Hs_txi_kallisto$counts))
```

Posteriormente, podemos construir un _DESeqDataSet_ (`Hs_ddsTxi_all`), un objeto utilizado para almacenar las _read counts_ y las cantidades intermedias estimadas (*intermediate estimated quantities*) durante el análisis estadístico, a partir del objeto `Hs_txi_kallisto` y mostrar información en muestras.

```{r Importacion de datos DESeqDataSetFromTximport, warning=FALSE}
# Importacion de los datos convirtiendolos en un objeto que puede leer Deseq.
Hs_ddsTxi_all <- DESeqDataSetFromTximport(Hs_txi_kallisto, Hs_samples, design = ~ dex) # Create a DESeq object from the tximport data
```

### Prefiltrado

Si bien no es necesario prefiltrar genes de bajo conteo antes de ejecutar las funciones DESeq2, hay dos razones que hacen útil el prefiltrado: 
1. al eliminar filas en las que hay muy pocas lecturas, reducimos el tamaño de la memoria del objeto de datos dds (`Hs_ddsTxi_all`), y aumentamos la velocidad de las funciones de transformación y _testing__ dentro de DESeq2. 
2. También puede mejorar las visualizaciones, ya que las características sin información para la expresión diferencial no se trazan.

Aquí realizamos un pre-filtrado mínimo para mantener sólo las filas que tienen al menos 10 lecturas en total.

```{r Prefiltrado, message=FALSE}
# Prefiltrado, eliminacion de genes con bajas cuentas
keep <- rowSums(counts(Hs_ddsTxi_all)) >= 10 # Si en una fila solo hay 10 cuentas (mapeo 10 veces)
Hs_ddsTxi_all <- Hs_ddsTxi_all[keep,] 
Hs_dds_all <- DESeq(Hs_ddsTxi_all) # run Differential expression analysis
```

Los pasos de análisis de expresión diferencial estándar están envueltos en una sola función, `DESeq`.

### Cuentas normalizadas para graficas (rlog)

Muchos métodos estadísticos comunes para el análisis exploratorio de datos multidimensionales, como el análisis de agrupación y componentes principales (PCA), funcionan mejor para datos que generalmente tienen el mismo rango de varianza en diferentes rangos de los valores de la media.

DESeq2 ofrece dos transformaciones para datos de conteo que estabilizan la varianza a través de la media: la __*transformación estabilizadora de varianza (VST)*__, y la transformación _regularizada de logaritmos_ o _rlog_.

En este caso, utilizaremos rlog. A pesar de que VST es mucho más rápido de computar y es menos sensible a los valores atípicos con conteos altos que el rlog, este último tiende a funcionar bien en conjuntos de datos pequeños ($n$ < 30).

```{r Normalizacion rlog}
Hs_all_normalized <- rlog(Hs_dds_all, blind=FALSE) # result rld, vst
Hs_all_normalized_db <- as.data.frame(assay(Hs_all_normalized))
head(Hs_all_normalized_db)
```

Tanto `vst` como `rlog` devuelven un objeto *DESeqTransform* basado en la clase *SummarizedExperiment*, es decir los valores transformados ya no son conteos.

En las llamadas a funciones anteriores, especificamos `blind = FALSE`, lo que significa que las diferencias entre las líneas celulares y el tratamiento (las variables en el diseño) no contribuirán a la tendencia esperada de varianza-media del experimento. 

### PCA

Un primer paso útil en un análisis de ARN-seq es a menudo evaluar la similitud general entre las muestras. Un gráfico PCA muestra las muestras en el plano 2D abarcadas por sus dos primeros componentes principales. Este tipo de gráfico es útil para visualizar el efecto general de las covariadas experimentales y los efectos _batch_.

```{r PCA}
plotPCA(Hs_all_normalized, intgroup=c("dex"))
```

Aquí, hemos utilizado la función `plotPCA` que viene con `DESeq2`. El término especificado por `intgroup` es el grupos de interés para etiquetar las muestras; le dicen a la función que debe usarlos para elegir colores.

En esta gráfica, lo que observamos es que las muestras control (solo tratadas con dimetilsulfóxido, DMSO) muestran diferencia significativa con respecto a las células inhibidas de la kinasa JNK, lo cual, de hecho, es lo esperado.

### Expresion diferencial

Como se mencionó antes, los pasos de análisis de expresión diferencial estándar están envueltos en una sola función, `DESeq`. Las tablas de resultados se generan utilizando la función `results()`, que extrae una tabla de resultados con cambios de _log2 fold_, valores p y valores p ajustados.

```{r Tabla resultados}
Hs_res_all <- results(Hs_dds_all)  # Save the results
Hs_res_all
```

- La primera columna, `baseMean`, es una media de los valores normalizados de conteo, divididos por los factores de tamaño (*size factors*), tomada sobre todas las muestras del DESeqDataSet (`Hs_dds_all`).
- La columna `log2FoldChange` es la estimación del tamaño del efecto (*effect size estimate.*). Nos dice cuánto parece haber cambiado la expresión del gen debido al tratamiento con SP6000125 (inhibidas de JKN) en comparación con las muestras tratadas con DMSO (control).
- Por supuesto, esta estimación tiene una incertidumbre asociada con ella, que está disponible en la columna `lfcSE`, la estimación de error estándar para la estimación del _log2 fold change_.
- La columna `pvalue` es el resultado de una prueba estadística que DESeq2 realiza para cada gen, en el que la hipótesis nula es que no hay efecto del tratamiento en el gen y que la diferencia observada entre el tratamiento y el control fue causada meramente por la variabilidad experimental (es decir, el tipo de variabilidad que se puede esperar entre diferentes muestras en el mismo grupo de tratamiento). 

También podemos resumir los resultados con la siguiente línea de código, que reporta alguna información adicional.

```{r summary tabla de resultados}
summary(Hs_res_all)
```

Nótese que hay muchos genes con expresión diferencial (5112 up y 4012 down) debido al tratamiento con SP600125 (inhibidor de enzimas JNK). Sin embargo, hay dos maneras de ser más estrictos acerca de qué conjunto de genes se consideran importantes:

1. reducir el umbral de falsos detectados (el umbral del `padj` en el cuadro de resultados)
2. elevar el umbral de _log2 fold change_ desde 0 usando el argumento `log2FoldChange` de los resultados. 

En este caso, tanto para extraer los genes sobreexpresados (Up) como para los subexpresados, reducimos el umbral de `padj` a menor a 0.5 y pedimos que el log2 fold change sea mayor o igual a 0.5.

```{r UP and DOWN genes}
# extraer UP
Hs_all_de_gene_matrix_UP  <- subset(Hs_res_all, padj < 0.05 & log2FoldChange >= 0.5)
write.table(Hs_all_de_gene_matrix_UP,file ="./Hs_all_DEG_kallisto_JNK_inh.tsv", quote=FALSE, sep="\t")
# Extraer nombres
Hs_all_de_gene_names_UP <- rownames(Hs_all_de_gene_matrix_UP)

# extraer down genes
Hs_all_de_gene_matrix_DOWN  <- subset(Hs_res_all, padj < 0.05 & log2FoldChange < -0.5)
write.table(Hs_all_de_gene_matrix_DOWN,file ="./Hs_all_DEG_kallisto_Control.tsv", quote=FALSE, sep="\t")
# Extraer nombres
Hs_all_de_gene_names_DOWN <- rownames(Hs_all_de_gene_matrix_DOWN)

# Numero de genes expresados
length(Hs_all_de_gene_names_UP)
length(Hs_all_de_gene_names_DOWN)
```

Tras este filtrado, encontramos que existen 3612 genes sobreexpresados y 2646 genes subexpresados.

### Volcano plot

En este caso, para visualizar los datos normalizados podemos hacer uso de un _volcano plot_ De esta manera, podremos dar cuenta fácilmente de los genes que tienen un valor $p$ de mayor significacia.

```{r}

Hs_de <- as.data.frame(Hs_res_all)
# add a column of NAs
Hs_de$diffexpressed <- "NO"
# if log2Foldchange > 0.6 and pvalue < 0.05, set as "UP" 
Hs_de$diffexpressed[Hs_de$log2FoldChange > 0.6 & Hs_de$pvalue < 0.05] <- "UP"
# if log2Foldchange < -0.6 and pvalue < 0.05, set as "DOWN"
Hs_de$diffexpressed[Hs_de$log2FoldChange < -0.6 & Hs_de$pvalue < 0.05] <- "DOWN"
# Create a new column "names" to de, that will contain the name of a subset if genes differentially expressed (NA in case they are not)
Hs_de$names <- NA
# filter for a subset of interesting genes
filter <- which(Hs_de$diffexpressed != "NO" & Hs_de$padj < 0.05 & (Hs_de$log2FoldChange >= 5  | Hs_de$log2FoldChange <= -5))
Hs_de$names[filter] <- rownames(Hs_de)[filter]
# grafica
png(file = "volcano05-res.png",
    width = 800, height = 800) # guardar el plot en formato png
ggplot(data=Hs_de, aes(x=log2FoldChange, y=-log10(pvalue), col=diffexpressed, label=names)) +
    geom_point() +
    scale_color_manual(values=c("blue", "black", "red")) + # cambiar colores de puntos
    theme_minimal() +
    geom_text_repel() +
    xlim(-15,15)

dev.off()
```

### Heatmap 

Utilizamos un mapa de calor para visualizar la agrupación de genes que llevan una señal. En este caso, seleccionamos los 20 genes con la mayor varianza entre las muestras.  Proporcionamos el _dataframe_ `` que indica a la función pheatmap cómo etiquetar las columnas.

```{r instalacion genefilter, eval=FALSE, include=FALSE}
BiocManager::install("genefilter")
```

```{r heatmap}
library("genefilter")
library("pheatmap")
topVarGenes <- head(order(rowVars(assay(Hs_all_normalized)), decreasing = TRUE), 20)  # Seleccion de mayores genes
mat  <- assay(Hs_all_normalized)[ topVarGenes, ]  # Matriz con mayores genes
mat  <- mat - rowMeans(mat)
anno <- as.data.frame(colData(Hs_all_normalized)[, c("sample","dex")]) # Anotaciones
pheatmap(mat, annotation_col = anno) # Grafica
```

Lo que podemos observar es que, para un conjunto de genes para los cuales las muestras tratadas con SP600125 (inhibidor de enzimas JNK) tienen mayor (en rojo) o menor (en azul) expresión génica.

#### Fuentes
http://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html#Downstream_DGE_in_Bioconductor
https://f1000research.com/articles/4-1070/v2#s2
http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#the-deseqdataset
https://bioconductor.org/packages/devel/bioc/vignettes/GenomicFeatures/inst/doc/GenomicFeatures.html
https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html


--------------------------------------------------------------------------------
# Graficas GO (Manuel)

- Instalar 'clusterProfiler', 'AnnotationDbi' y Base de Datos de homo_sapiens 'org.Hs.eg.db'
```{r, echo=FALSE}
# Comando
install.packages('AnnotationDbi')

# Programa de enrichment analysis
BiocManager::install("clusterProfiler")

# Instalar BD
BiocManager::install("org.Hs.eg.db")
```

- Extraer información de BD
```{r, eval=FALSE}
#Importar libreria
library(clusterProfiler) #Enrichment analysis
library (AnnotationDbi)
library(org.Hs.eg.db) # Human DB

# Tomar tabla de datos de DESEQ2
data = Hs_res_all
class(data)

#Eliminar NAs
data2 = na.omit(data)

# Tomar solo los genes posiblemente diferentemente expresados significativoas
# Solamente requerimos los nombres de lo anterior, por lo que:
genes_to_test = rownames(data2[data2$log2FoldChange > 0.5 & data2$padj < 0.5, ])

# Convertirlo en matriz y utilizar solo los primeros 100 IDs, ya que son un total de 12,999
genes_to_test = as.matrix(genes_to_test)
genes_to_test = genes_to_test[1:100,]

# Modificar nombres, solo quiero los primeros 15 caracteres
genes_to_test = as.matrix(genes_to_test) #convertir a matriz
for (i in 1:100) {
genes_to_test[i,]=substr(genes_to_test[i,], start=1, stop=15)                           
}

# Analisis terminos GO de lor primero 100 terminos, ya que en total son 12,999 y son muchos terminos
Go_results <- enrichGO(gene=genes_to_test, OrgDb="org.Hs.eg.db", keyType = "ENSEMBL", ont = "BP")
```

- Convertir en data frame
```{r}
# Convwertir en data-frame
as.data.frame(Go_results)
```

- Generar la gráfica
```{r}
 # Generar la plot de los primeros 20 genes
plot(barplot(Go_results, showCategory = 20))
```

- Interpretación de la gráfica


## Generar con subgrupos UP

- Con subgrupo UP
```{r, eval=FALSE}
#Importar libreria
library(clusterProfiler) #Enrichment analysis
library (AnnotationDbi)
library(org.Hs.eg.db) # Human DB

# Tomar tabla de datos de DESEQ2
data_up = Hs_all_de_gene_matrix_UP # Grupo UP
data_down = Hs_all_de_gene_matrix_DOWN

#Eliminar NAs
data_up = na.omit(data_up)
data_down = na.omit(data_down)

# Tomar solo los genes posiblemente diferentemente expresados significativos. Solamente requerimos los nombres de lo anterior, por lo que:
genes_up = rownames(data_up[data_up$log2FoldChange > 0.5 & data_up$padj < 0.5, ])

# No me arroja nada, por lo que no hay nada significativo
genes_down = rownames(data_down[data_down$log2FoldChange > 0.5 & data_down$padj < 0.5, ]) 

# Convertirlo en matriz y utilizar solo los primeros 100 IDs del grupo UP
genes_up = as.matrix(genes_up)
genes_up = genes_up[1:100,]

# Convertirlo en matriz y utilizar solo los primeros 100 IDs del grupo UP
genes_down = as.matrix(genes_down)
# genes_down = genes_down[1:100,]

# Modificar nombres, solo quiero los primeros 15 caracteres del grupo UP
genes_up = as.matrix(genes_up) #convertir a matriz
for (i in 1:100) {
genes_up[i,]=substr(genes_up[i,], start=1, stop=15)                           
}

# Análisis términos GO de lor primero 100 términos, ya que en total son 12,999 y son muchos términos
Go_results <- enrichGO(gene=genes_up, OrgDb="org.Hs.eg.db", keyType = "ENSEMBL", ont = "BP")

```


- Convertir en data frame
```{r}
# Convwertir en data-frame
as.data.frame(Go_results)
```

- Generar la gráfica
```{r}
 # Generar la plot de los primeros 20 genes
plot(barplot(Go_results, showCategory = 20))
```
- Interpretación de la gráfica



--------------------------------------------------------------------------------

## Discusión

Los resultados obtenidos del pipeline dan evidencia a que los transposones han contribuido de forma importante a la regulación génica del trofoblasto humano ya que hay genes de elementos transponibles que tienen mayor expresión génica. Resultado también reportado en el paper correspondiente al proyecto. 

Adicionalmente, buscamos tres artículos más en donde se habla de la función biológica de estos transposones, incluyendo los retrovirus endógenos (ERV). En uno de los artículos que lleva por título `Endogenous Retroviruses in Trophoblast Differentiation and Placental Development` evidencia que la presencia de ERV expresados en los sincitiotrofoblastos multinucleados de la placenta de varios organismos como humano, ratón y conejo desempeñan un papel esencial en el desarrollo de la placenta y que estos ERVfueron seleccionados positivamente para desempeñar un papel fundamental en la evolución de los mamíferos placentarios y el desarrollo de la viviparidad.

--------------------------------------------------------------------------------

# Referencias

FastQC tutorial & FAQ. (n.d.). Msu.edu. Retrieved March 16, 2023, from https://rtsf.natsci.msu.edu/genomics/tech-notes/fastqc-tutorial-and-faq/

Should I remove PCR duplicates from my RNA-seq data? (n.d.). Ucdavis.edu. Retrieved March 16, 2023, from https://dnatech.genomecenter.ucdavis.edu/faqs/should-i-remove-pcr-duplicates-from-my-rna-seq-data/

(N.d.-a). Biostars.org. Retrieved March 16, 2023, from https://www.biostars.org/p/14283/

(N.d.-b). Ridom.de. Retrieved March 16, 2023, from https://www.ridom.de/seqsphere/u/FASTQ_Quality_Control_(FastQC).html

GEO Accession viewer. (n.d.-a). Nih.gov. Retrieved March 16, 2023, from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE200762

GEO Accession viewer. (n.d.-b). Nih.gov. Retrieved March 16, 2023, from https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM6043329




