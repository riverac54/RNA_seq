---
title: "Reporte_05"
author: "Jessica Garcia, Manuel Rivera, Axel Rodriguez"
date: "2023-03-03"
output:
  html_document:
    toc: true # table of content true
    toc_float: yes
    toc_depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite
    highlight: tango  # specifies the syntax highlighting style
  pdf_document: 
    toc: true
    toc_depth: 3
    number_sections: true
    pandoc_args: --listings # Para que no se salga el codigo del margen
    includes:
      in_header: preamble.tex
---


# Analisis MultiQC rawdata

- Todas son de 150 bp.

- El SRA que tiene mas secuenciaciones es 'SRR18745762' con $66.1 \space Millones$. El SRA con menos secuencias fue 'SRR18745771' con $3 \space Millones$.

- El SRA 'SRR18745762' tiene $75.6 \% $ de duplicados. Si bien esto podría suponer un problema, debemos recordar que trabajamos con RNA-seq y los duplicados se puede deber a la expresion de un pequeño numero de genes. En RRna-seq no deben de eliminarse los duplicados, a menos que tengan UMIs(barcodes).

- Esta grafica nos muestra que todos los archivos tuvieron una buena calidad. Siendo la muestra 'SRR18745771_1' la que tiene la calidad mas baja de $24.53$, es decir, el error esta entre $0.01<error<.001$

- https://dnatech.genomecenter.ucdavis.edu/faqs/should-i-remove-pcr-duplicates-from-my-rna-seq-data/
- https://www.biostars.org/p/14283/ 

## Per Sequence GC Content 

- Solamente 2 muestras salieron bien, el resto tuvieron alertas (11) o fueron marcadas como errores (9). Esto es normal, ya que las primeras 10-12 bases son resultado del hexamero utilizado como primers, este hexamero esta compuesto de forma aleatoria.

- https://hbctraining.github.io/Intro-to-rnaseq-hpc-salmon/lessons/qc_fastqc_assessment.html#:~:text=The%20%E2%80%9CPer%20sequence%20GC%20content,expected%20%25%20GC%20for%20the%20organism.

## Per Base N Content 

- Todas las muestras pasaron la prueba, esto indica que todas las posiciones tienen asignadas una base.

- https://rtsf.natsci.msu.edu/sites/_rtsf/assets/File/FastQC_TutorialAndFAQ_080717.pdf

## Overrepresented sequence

- Es posible que la sobrerepresentacion de las secuencias se deban a que un transcriptoma es muy abundante.

- https://rtsf.natsci.msu.edu/genomics/tech-notes/fastqc-tutorial-and-faq/#:~:text=Overrepresented%20Sequences,to%20try%20to%20identify%20it.

## Adapter Content 

- Solamente 2 muestras tienen alerta 'SRR18745771_1 y SRR18745768_1' esto ocurre debido a que el adaptador esta presente en mas del $5 \% $ de las lecturas. El resto de las muestras tienen errores, esto indica que el adaptador esta presente en mas del $10 \% $ de las lecturas.

- https://www.ridom.de/seqsphere/u/FASTQ_Quality_Control_(FastQC).html

--------------------------------------------------------------------------------
# Analisis MultiQC sin adaptadores







--------------------------------------------------------------------------------
# Kallisto pseudo alligment

- Descargar transcriptoma de referencia
```bash
# Generar transcriptoma de referencia meaidnte el JOB 'Transcript_down.sge', con las instrucciones:
wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.transcripts.fa.gz 

# Ubicacion transciptoma de referencia
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/gencode.v43.transcripts.fa.gz

# Carpeta de archivos kallisto
mkdir kallisto_quant_test
```

- Generar un JOB 'Kallisto_down_data.sge'.
```bash
#!/bin/bash
#
# Use Current working directory
#$ -cwd
#
# Join stdout and stderr
#$ -j n
#
# Run job through bash shell
#$ -S /bin/bash
#
# You can edit the script since this line
#
# Your job name
#$ -N Kallisto_down_data
#
# Send an email after the job has finished
#$ -m e
#$ -M rivera20c3@gmail.com
#
#
# If modules are needed, source modules environment (Do not delete the next line):
. /etc/profile.d/modules.sh
#
# Add any modules you might require:
module load kallisto/0.45.0
#
# Write your commands in the next line

# Generar index de kallisto
kallisto index ./gencode.v43.transcripts.fa.gz -i ./kallisto_quant_test/HS_ref.kidx 

# - i nombre del archivo de salida, i.e., indice
#- Input =  gencode.v43.transcripts.fa.gz, transcriptoma de referencia

 # Paired-end  
for file in ./data_trimmed/*_1_trimmed.fastq.gz                                                 # Read1
do
  clean=$(echo $file | sed 's/_trimmed//;s/\.fastq\.gz//;s/_1//')         # Nombre de la carpeta de salida, mismo nombre de SRA
  file_2=$(echo ${clean}_2_trimmed.fastq.gz| sed 's/FP/RP/')                                            # Read2
  kallisto quant --index ./kallisto_quant_test/HS_ref.kidx --output-dir ./kallisto_quant_test/${clean} --threads 12 ${file} ${file_2}
done
```


- Mostrar resultados del alineamiento
```bash

# JOB 'Kallisto_down_data.sge' para generar el alineamiento
cd ./Kallisto_down_data.sge

# Se encuentran en el archivo de errores del JOB
cat Kallisto_down_data.e276381 
```


#################################################################################
--------------------------------------------------------------------------------
# Descripcion de los datos

- Tipo de bibliotecas: Paired-end

- Método de selección: ARN Total, cDNA ****************** PREGUNTA A EVELIA: cDNA ¿es complementary DNA?

- Número de transcriptomas: 6 transcriptomas 

- Número de réplicas biológicas: 3 con un total de 11 corridas ***************** PREGUNTA A EVELIA: Las muestras las obtuvimos de NCBI y son 6. Cabe destacar que la muestra #4 tiene 2 corridas, la #5 y #6 tienen 3 corridas, así que el número real de archivos que vamos a descargar en el cluster son 11.

- Secuenciador: Illumina NovaSeq 6000

- Distribución de las muestras: 

  Control: tratamiento con DMSO (hTSC, DMSO) - SRR18745765 (repbio1), SRR18745766 (repbio1), SRR18745770 (repbio2), SRR18745771 (repbio2), SRR18745772 (repbio2), SRR18745767 (repbio3), SRR18745768 (repbio3), SRR18745769 (repbio3) 

  Tratamiento con SP600125 (hTSC, SP600125) - SRR18745764 (repbio1), SRR18745763 (repbio2) y SRR18745762 (repbio3)

- Profundidad de secuenciación de cada transcriptoma: ************************** PREGUNTA ¿DÓNDE VEO ESTO? 

--------------------------------------------------------------------------------

# Abstract

¿Qué comparamos?

¿Qué tipo de datos analizaste? RNA-seq

¿Qué programas usaste y por qué? Kllisto quant, FastQC, trimm... 

Información breve de que obtuviste

Máximo 200 palabras

--------------------------------------------------------------------------------

# Rutas de trabajo generadas en el proyecto

0. Carpeta de trabajo del equipo 

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens 
```

1. Contiene los nombres de los SRA

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/human_fastq.txt
```

2. Contiene las instrucciones de descarga de los datos (SRA) y el cambio a Fastq de los mismos.

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/SRAData_dow.sh
```

3. Contiene el JOB de descarga de los SRA

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/SRA_run.sge
```

4. Contiene los datos crudos y sus fastqc.gz que se enviaron a la carpeta FastQC_rawData para su análisis.

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/data
```

5. Contiene el análisis de calidad fastqc de los datos crudos

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_rawData
```

#####################################

6. Contiene el JOB para realizar la limpieza de adaptadores **** MANUEL Contiene el JOB generado para realizar el análisis de calidad de la 'rawdata'

```{bash}
 /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/Trimmed_run.sge
```

7. Contiene los adaptadores para paired-end *****NO ESTOY SEGURA, VIVALDO LO PUSO. CHECAR.

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/TruSeq3-PE.fa
```

7. Contiene las muestras (SRA) sin adaptadores

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/data_trimmed
```

8. Contiene el analisis MultiQC de datos sin adaptadores

```{bash}
cd /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_trimmed/multiqc_report.html
```


#Comandos de descarga del Vivaldo. SE OCUPAN + TARDE. **********************

```{bash}
# Descargar analisis FastQC --> computadora
rsync -rptuvl mrivera@dna.lavis.unam.mx:/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_rawData ./Documents

# Descargar analisis FastQC --> computadora
rsync -rptuvl mrivera@dna.lavis.unam.mx:/mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/Homo_sapiens/FastQC_rawData ./Documents

```


# Resultados y discusión 

## Calidad de secuencias (FastQC y multiQC), tanto de raw data como después de la limpieza de adaptadores.

Auí van las imagenes que quiero poner. 

## Limpieza de adaptadores

En una carpeta creada llamada data_trimmed vamos a almacenar las secuencias limpias mediante un job llamado Trimmed_run.sge

```{bash}
module load trimmomatic/0.33
mkdir data_trimmed

# Crear symlink
ln -s /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/adapters/TruSeq3-PE.fa .
ln -s /mnt/Timina/bioinfoII/rnaseq/BioProject_2023/rawData/adapters/TruSeq-SE.fa .

# paired-end
cd data
for i in *_1.fastq.gz;
do echo
trimmomatic PE -threads 8 -phred33 $i "${i%_1.fastq.gz}_2.fastq.gz" \
../data_trimmed/"${i%_1.fastq.gz}_1_trimmed.fastq.gz" ../data_trimmed/"${i%_1.fastq.gz}_1_unpaired.fastq.gz" \
../data_trimmed/"${i%_1.fastq.gz}_2_trimmed.fastq.gz" ../data_trimmed/"${i%_1.fastq.gz}_2_unpaired.fastq.gz" \
ILLUMINACLIP:../TruSeq3-PE.fa:2:30:10 LEADING:3 TRAILING:3 SLIDINGWINDOW:5:20 MINLEN:60
done

# Regresar
cd ../
```



## Alineacion 

## Programa de predicción de cuentas

# Expresión diferencial

## Análisis (de expresión diferencial) funcional 

El objetivo del análisis diferencial de expresión es realizar análisis estadísticos para tratar de descubrir cambios en los niveles de expresión de características definidas (genes, transcripciones, exones) entre grupos experimentales con muestras replicadas.

### Instalaciones 

La mayoría de las herramientas populares para el análisis de expresión diferencial están disponibles como paquetes de R / Bioconductor. Bioconductor es un proyecto R y repositorio que proporciona un conjunto de paquetes y métodos para el análisis de datos *omicos*.

Para este proyecto, serán necesarias las siguientes paqueterías:

```{r Librerias, results='hide', message=FALSE}
library(tximport)
library(tidyverse)
library(DESeq2)
library(ggplot2)
library(ggrepel)
library(rhdf5)
```

- `tximport` proporciona una manera de importar y resumir datos a nivel de transcripción generados a partir de herramientas de cuantificación (como `salmon`, `kallisto` y `STAR`) en un formato común que se puede utilizar para el análisis posterior.
- El paquete `tidyverse` es una colección de paquetes en R diseñados para trabajar juntos para hacer más fácil y eficiente la manipulación, visualización y análisis de datos. Su función principal es proporcionar un conjunto coherente e intuitivo de herramientas para la limpieza, transformación y visualización de datos.
- La función principal del paquete `DESeq2` es identificar genes que se expresan diferencialmente entre dos o más condiciones experimentales, basándose en datos de recuento de experimentos de secuenciación de alto rendimiento. DESeq2 is based on the hypothesis that most genes are not differentially expressed. 
- El paquete `ggplot2` proporciona una amplia gama de funciones para crear varios tipos de gráficos, que permite a los usuarios describir y crear *plots* complejos utilizando un conjunto simple y coherente de sintaxis y principios.
- El paquete `ggrepel` en R es un paquete para crear etiquetas de texto que se ajustan automáticamente para evitar solaparse con otras etiquetas o puntos de datos en un gráfico. Su función principal es proporcionar una solución flexible y fácil de usar para etiquetar puntos, líneas u otros elementos gráficos en *plots* complejos creados con `ggplot2` u otros paquetes.

#### Importacion de datos de kallisto en R (*Import transcript-level estimates*)

```{r Intalacion GenomicFeatures, eval=FALSE, include=FALSE}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("GenomicFeatures")
```

Primero, we create a named vector pointing to the quantification files (los abundance.tsv). We will create a vector of filenames first by reading in a table that contains the SRR, and then combining this with "." and "abundance.tsv".

```{r Metadatos}
# > H. sapiens
# generar tabla de metadatos
Hs_metadata.tsv <- data.frame("SRA" =c("SRR18745765","SRR18745766",  # Control R1
                                       "SRR18745770", "SRR18745771", "SRR18745772",  # Control R2
                                       "SRR18745767", "SRR18745768", "SRR18745769",  # Control R3
                                       "SRR18745764", "SRR18745763", "SRR18745762"),  # JNK_inh
                              "sample" = c("control_1_R1","control_2_R1",
                                           "control_1_R2", "control_2_R2",  "control_3_R2", 
                                           "control_1_R3", "control_2_R3",  "control_3_R3",
                                           "JNK_inh_R1", "JNK_inh_R2", "JNK_inh_R3") , 
                              "dex" = c(rep("control",8), 
                                        rep("JNK_inh",3)), 
                              "species" = "Homo_sapiens")
```

```{r Samples and Files}
# Anotacion articulo
Hs_samples <- Hs_metadata.tsv
Hs_samples
Hs_files   <- file.path("./SRA_experiments", Hs_samples$SRA,"abundance.h5") # Crear ruta a cada archivo abundance de cada SRA
names(Hs_files) <- Hs_samples$SRA # Nombrar las rutas con el nombre de su correspondiente SRA
all(file.exists(Hs_files))
```

- `file.path` te permite crear una ruta a un archivo específico en un directorio de trabajo. En este caso, una ruta para cada archivo `abundance.tsv`

Las transcripciones deben asociarse con identificadores genéticos (*gene IDs*) para el resumen a nivel genético (*gene-level summarization*). Si esa información está presente en los archivos, podemos omitir este paso. Para Salmon, Sailfish, y kallisto los archivos sólo proporcionan el ID de la transcripción. 

Primero hacemos un *data-frame* llamado `tx2gene` con dos columnas: 
  1) ID de la transcripción y 
  2) ID del gen. 
Los nombres de las columnas no importan, pero este orden de columnas debe ser utilizado. El ID de la transcripción debe ser el mismo utilizado en los archivos
`abundance.tsv`. 

```{r creacion archivo csv, eval=FALSE, echo=T}
library(GenomicFeatures)
txdb <- makeTxDbFromGFF(file="gencode.v43.annotation.gtf")
saveDb(x=txdb, file = "gencode.v43.annotation.TxDb")
k <- keys(txdb, keytype = "TXNAME")
tx2gene <- select(txdb, k, "GENEID", "TXNAME")
write.table(tx2gene, "tx2gene.gencode.v43.csv", sep = "\t", row.names = FALSE)
```

Luego leemos en una tabla `tx2gene` (pre-construida), la cual vincula las transcripciones a los genes para este conjunto de datos:

```{r tabla tx2gene Hs}
Hs_tx2gene   <- read.csv("tx2gene.gencode.v43.csv", sep=",",header=TRUE) 
head(Hs_tx2gene)
```

- `read.csv` lee un archivo en formato tabla y crea un *data frame* a partir de él, con casos correspondientes a líneas y variables a campos del archivo.

El paquete `tximport` tiene una sola función para importar estimaciones a nivel de transcripción, es decir los datos de cuantificación necesarios para DESeq2.
- El argumento `type` se utiliza para especificar qué software se utilizó para la estimación, en este caso fue `kallisto`.   
- Se devuelve una lista simple con matrices, `"abundance"`,  `"counts"` y     `"length"` , donde la información del nivel de transcripción se resume al nivel genético.   

Típicamente, la abundancia es proporcionada por las herramientas de cuantificación como TPM (transcripciones-por-millón), mientras que los recuentos son recuentos estimados (posiblemente fraccionales), y la matriz de "longitud" contiene las longitudes efectivas del gen.   
La matriz `"length"` se puede utilizar para generar una matriz de desplazamiento para el análisis diferencial a nivel genético de matrices de conteo (*offset matrix for downstream gene-level differential analysis*), como se muestra abajo.

```{r tximport kallisto}
Hs_txi_kallisto <- tximport(Hs_files, type = "kallisto", tx2gene=Hs_tx2gene, ignoreAfterBar=TRUE)
names(Hs_txi_kallisto)
head(Hs_txi_kallisto$counts)
```

Note que añadimos un argumento adicional en este fragmento de código, `ignoreAfterBar=TRUE`. Esto se debe a que las transcripciones del código genético tienen nombres como “ENST00000456328. 2|ENSG00000223972. 5|. . . ”, aunque nuestra tabla tx2gene solo incluye el primer identificador “ENST”. Por lo tanto, queremos dividir los nombres de las filas de la matriz de cuantificación entrante en la primera barra “|”, y solo usar esto como identificador.

El usuario debe asegurarse de que los nombres de fila de la tabla `Hs_samples` se alineen con los nombres de columna de `Hs_txi_kallisto$counts`, si hay nombres de fila.

```{r Nombre transcriptomas}
# nombre de los transcriptomas
rownames(Hs_samples) <- Hs_samples$sample # Nombre de cada fila como nombre de la muestra
colnames(Hs_txi_kallisto$counts) <-rownames(Hs_samples) # Nombre de cada columna como nombre de cada muestra
head(rownames(Hs_samples))
head(colnames(Hs_txi_kallisto$counts))
```

Posteriormente, podemos construir un _DESeqDataSet_ (`Hs_ddsTxi_all`), un objeto utilizado para almacenar las _read counts_ y las cantidades intermedias estimadas (*intermediate estimated quantities*) duarnte el análisis estadístico, a partir del objeto `Hs_txi_kallisto` y mostrar información en muestras.

```{r Importacion de datos DESeqDataSetFromTximport, warning=FALSE}
# Importacion de los datos convirtiendolos en un objeto que puede leer Deseq.
Hs_ddsTxi_all <- DESeqDataSetFromTximport(Hs_txi_kallisto, Hs_samples, design = ~ dex) # Create a DESeq object from the tximport data
```

### Prefiltrado

Si bien no es necesario prefiltrar genes de bajo conteo antes de ejecutar las funciones DESeq2, hay dos razones que hacen útil el prefiltrado: 
1. al eliminar filas en las que hay muy pocas lecturas, reducimos el tamaño de la memoria del objeto de datos dds (`Hs_ddsTxi_all`), y aumentamos la velocidad de las funciones de transformación y _testing__ dentro de DESeq2. 
2. También puede mejorar las visualizaciones, ya que las características sin información para la expresión diferencial no se trazan.

Aquí realizamos un pre-filtrado mínimo para mantener sólo las filas que tienen al menos 10 lecturas en total.

```{r Prefiltrado, message=FALSE}
# Prefiltrado, eliminacion de genes con bajas cuentas
keep <- rowSums(counts(Hs_ddsTxi_all)) >= 10 # Si en una fila solo hay 10 cuentas (mapeo 10 veces)
Hs_ddsTxi_all <- Hs_ddsTxi_all[keep,] 
Hs_dds_all <- DESeq(Hs_ddsTxi_all) # run Differential expression analysis
```

Los pasos de análisis de expresión diferencial estándar están envueltos en una sola función, `DESeq`.

### Cuentas normalizadas para graficas (rlog)

Muchos métodos estadísticos comunes para el análisis exploratorio de datos multidimensionales, como el análisis de agrupación y componentes principales (PCA), funcionan mejor para datos que generalmente tienen el mismo rango de varianza en diferentes rangos de los valores de la media.

DESeq2 ofrece dos transformaciones para datos de conteo que estabilizan la varianza a través de la media: la __*transformación estabilizadora de varianza (VST)*__, y la transformación _regularizada de logaritmos_ o _rlog_.

En este caso, utilizaremos rlog. A pesar de que VST es mucho más rápido de computar y es menos sensible a los valores atípicos con conteos altos que el rlog, este último tiende a funcionar bien en conjuntos de datos pequeños ($n$ < 30).

```{r Normalizacion rlog}
Hs_all_normalized <- rlog(Hs_dds_all, blind=FALSE) # result rld, vst
Hs_all_normalized_db <- as.data.frame(assay(Hs_all_normalized))
head(Hs_all_normalized_db)
```

Tanto `vst` como `rlog` devuelven un objeto *DESeqTransform* basado en la clase *SummarizedExperiment*, es decir los valores transformados ya no son conteos.

En las llamadas a funciones anteriores, especificamos `blind = FALSE`, lo que significa que las diferencias entre las líneas celulares y el tratamiento (las variables en el diseño) no contribuirán a la tendencia esperada de varianza-media del experimento. 

## PCA

```{r}
plotPCA(Hs_all_normalized, intgroup=c("dex"))
```

# Expresion diferencial (TODOS LOS TRANSCRITOS)

```{r}
Hs_res_all <- results(Hs_dds_all)  # Save the results
mcols(Hs_res_all)$description # contraste shoot vs root
#https://github.com/COMBINE-lab/salmon/issues/581
```

```{r}
# extraer UP
Hs_all_de_gene_matrix_UP  <- subset(Hs_res_all, padj < 0.05 & log2FoldChange >= 0.5)
write.table(Hs_all_de_gene_matrix_UP,file ="./Hs_all_DEG_kallisto_JNK_inh.tsv", quote=FALSE, sep="\t")
# Extraer nombres
Hs_all_de_gene_names_UP <- rownames(Hs_all_de_gene_matrix_UP)
```


```{r}
# extraer down genes
Hs_all_de_gene_matrix_DOWN  <- subset(Hs_res_all, padj < 0.05 & log2FoldChange < -0.5)
write.table(Hs_all_de_gene_matrix_DOWN,file ="./Hs_all_DEG_kallisto_Control.tsv", quote=FALSE, sep="\t")
# Extraer nombres
Hs_all_de_gene_names_DOWN <- rownames(Hs_all_de_gene_matrix_DOWN)
```

```{r}
# Numero de genes expresados
length(Hs_all_de_gene_names_UP)
length(Hs_all_de_gene_names_DOWN)
```

# Volcano plot

```{r}
Hs_de <- as.data.frame(Hs_res_all)
# add a column of NAs
Hs_de$diffexpressed <- "NO"
# if log2Foldchange > 0.6 and pvalue < 0.05, set as "UP" 
Hs_de$diffexpressed[Hs_de$log2FoldChange > 0.6 & Hs_de$pvalue < 0.05] <- "UP"
# if log2Foldchange < -0.6 and pvalue < 0.05, set as "DOWN"
Hs_de$diffexpressed[Hs_de$log2FoldChange < -0.6 & Hs_de$pvalue < 0.05] <- "DOWN"
# Create a new column "names" to de, that will contain the name of a subset if genes differentially expressed (NA in case they are not)
Hs_de$names <- NA
# filter for a subset of interesting genes
filter <- which(Hs_de$diffexpressed != "NO" & Hs_de$padj < 0.05 & (Hs_de$log2FoldChange >= 5  | Hs_de$log2FoldChange <= -5))
Hs_de$names[filter] <- rownames(Hs_de)[filter]
# grafica
png(file = "volcano05-res.png",
    width = 800, height = 800) # guardar el plot en formato png
ggplot(data=Hs_de, aes(x=log2FoldChange, y=-log10(pvalue), col=diffexpressed, label=names)) +
    geom_point() +
    scale_color_manual(values=c("blue", "black", "red")) + # cambiar colores de puntos
    theme_minimal() +
    geom_text_repel() +
    xlim(-15,15)

dev.off()
```

# Heatmap 

```{r}
library("pheatmap")
# los primeros 20 genes
select <- order(rowMeans(counts(Hs_dds_all,normalized=TRUE)),
                decreasing=TRUE)[1:20]
df <- as.data.frame(colData(Hs_dds_all)[,c("dex", "sample")])

#heatmap
pheatmap(assay(Hs_all_normalized)[select,], cluster_rows=FALSE, show_rownames=FALSE,
         cluster_cols=FALSE, annotation_col=df)
```

#### Fuentes
http://bioconductor.org/packages/release/bioc/vignettes/tximport/inst/doc/tximport.html#Downstream_DGE_in_Bioconductor
https://f1000research.com/articles/4-1070/v2#s2
http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#the-deseqdataset
https://bioconductor.org/packages/devel/bioc/vignettes/GenomicFeatures/inst/doc/GenomicFeatures.html
https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html


<<<<<<< HEAD

--------------------------------------------------------------------------------
# Graficas GO (Manuel)

- Instalar 'clusterProfiler', 'AnnotationDbi' y Base de Datos de homo_sapiens 'org.Hs.eg.db'
```{r, echo=FALSE}
# Comando
install.packages('AnnotationDbi')

# Programa de enrichment analysis
BiocManager::install("clusterProfiler")

# Instalar BD
BiocManager::install("org.Hs.eg.db")
```

- Extraer informacion de BD
```{r, eval=FALSE}
#Importar libreria
library(clusterProfiler) #Enrichment analysis
library (AnnotationDbi)
library(org.Hs.eg.db) # Human DB

# Tomar tabla de datos de DESEQ2
data = Hs_res_all
class(data)

#Eliminar NAs
data2 = na.omit(data)

# Tomar solo los genes posiblemente diferentemente expresados significativoas
# Solamente requerimos los nombres de lo anterior, por lo que:
genes_to_test = rownames(data2[data2$log2FoldChange > 0.5 & data2$padj < 0.5, ])

# Convertirlo en matriz y utilizar solo los primeros 100 IDs, ya que son un total de 12,999
genes_to_test = as.matrix(genes_to_test)
genes_to_test = genes_to_test[1:100,]

# Modificar nombres, solo quiero los primeros 15 caracteres
genes_to_test = as.matrix(genes_to_test) #convertir a matriz
for (i in 1:100) {
genes_to_test[i,]=substr(genes_to_test[i,], start=1, stop=15)                           
}

# Analisis terminos GO de lor primero 100 terminos, ya que en total son 12,999 y son muchos terminos
Go_results <- enrichGO(gene=genes_to_test, OrgDb="org.Hs.eg.db", keyType = "ENSEMBL", ont = "BP")
```

- Convertir en data frame
```{r}
# Convwertir en data-frame
as.data.frame(Go_results)
```

- Generar la grafica
```{r}
 # Generar la plot de los primeros 20 genes
plot(barplot(Go_results, showCategory = 20))
```

- Interpretacion de la grafica


## Generar con subgrupos UP

- Con subgrupo UP
```{r, eval=FALSE}
#Importar libreria
library(clusterProfiler) #Enrichment analysis
library (AnnotationDbi)
library(org.Hs.eg.db) # Human DB

# Tomar tabla de datos de DESEQ2
data_up = Hs_all_de_gene_matrix_UP # Grupo UP
data_down = Hs_all_de_gene_matrix_DOWN

#Eliminar NAs
data_up = na.omit(data_up)
data_down = na.omit(data_down)

# Tomar solo los genes posiblemente diferentemente expresados significativoas. Solamente requerimos los nombres de lo anterior, por lo que:
genes_up = rownames(data_up[data_up$log2FoldChange > 0.5 & data_up$padj < 0.5, ])

# No me arroja nada, por lo que no hay nada significativo
genes_down = rownames(data_down[data_down$log2FoldChange > 0.5 & data_down$padj < 0.5, ]) 

# Convertirlo en matriz y utilizar solo los primeros 100 IDs del grupo UP
genes_up = as.matrix(genes_up)
genes_up = genes_up[1:100,]

# Convertirlo en matriz y utilizar solo los primeros 100 IDs del grupo UP
genes_down = as.matrix(genes_down)
# genes_down = genes_down[1:100,]

# Modificar nombres, solo quiero los primeros 15 caracteres del grupo UP
genes_up = as.matrix(genes_up) #convertir a matriz
for (i in 1:100) {
genes_up[i,]=substr(genes_up[i,], start=1, stop=15)                           
}

# Analisis terminos GO de lor primero 100 terminos, ya que en total son 12,999 y son muchos terminos
Go_results <- enrichGO(gene=genes_up, OrgDb="org.Hs.eg.db", keyType = "ENSEMBL", ont = "BP")

```


- Convertir en data frame
```{r}
# Convwertir en data-frame
as.data.frame(Go_results)
```

- Generar la grafica
```{r}
 # Generar la plot de los primeros 20 genes
plot(barplot(Go_results, showCategory = 20))
```
- Interpretacion de la grafica



>>>>>>> 0220df6d942e339d6e75704006e4138c2428516d


